"""
Plot the results of your training.

Many ideas borrowed from https://www.bastibl.net/publication-quality-plots/
"""
from typing import Tuple, List, Callable, Union, Any, Optional
import argparse
from collections import namedtuple

import os
import pathlib

import pandas as pd
import numpy as np

import matplotlib as mpl
import matplotlib.pyplot as plt

import logging

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

# mpl.use('pdf')

plt.style.use('seaborn-whitegrid')

plt.rc('font', family='serif', serif='Times')
plt.rc('text', usetex=True)
plt.rc('xtick', labelsize=8)
plt.rc('ytick', labelsize=8)
plt.rc('axes', labelsize=8)

WIDTH = 3.487
HEIGHT = WIDTH / 1.618

Stats = namedtuple('Stats', ['mean', 'stddev', 'ci'])


def parse_args():
    parser = argparse.ArgumentParser(
        description='Plot results generated by running a safe_rl algorithm',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('--logdir', help='Path to directory with the logs (if file, will plot single plot)',
                        metavar='LOG_DIRECTORY', nargs='+')
    parser.add_argument('--title', help='Title of plot', default='Training data')
    parser.add_argument('--output', help='Where to store the figure')
    parser.add_argument('--pdf-output', help='Set the output to be a PDF', action='store_true')

    data_g = parser.add_argument_group('Data Processing')
    data_g.add_argument('--smooth-span', help='Smooth span of the Exponential-Mean smoothing window', default=50,
                        type=lambda x: x if x else None)
    data_g.add_argument('--col', help='Names of the columns for each log file', metavar='COLS', nargs='*')

    plot_g = parser.add_argument_group('Plot options')
    plot_g.add_argument('--name', help='Names of the plots for each log directory', metavar='PLOT_NAME', nargs='+')
    plot_g.add_argument('--plot-cols', help='Specify name of columns to plot for each subplot', metavar='COLS',
                        nargs='*')
    plot_g.add_argument('--subplot-shape', help='Shape of subplots', metavar=('NROWS', 'NCOLS'), nargs=2, type=int,
                        default=(1, 1))
    plot_g.add_argument('--width', help='Width of 1 subplot', default=WIDTH, type=float)
    plot_g.add_argument('--height', help='Height of 1 subplot', default=HEIGHT, type=float)
    plot_g.add_argument('--sharex', help='Set if subplots share X-axis', action='store_true')
    plot_g.add_argument('--sharey', help='Set if subplots share Y-axis', action='store_true')

    plot_g.add_argument('--xlabel', help='X-axis labels for subplots', nargs='+')
    plot_g.add_argument('--ylabel', help='Y-axis labels for subplots', nargs='+')
    plot_g.add_argument('--no-xtight', dest='xtight', help='Tight limit to X-axis', action='store_false')
    plot_g.add_argument('--ytight', help='Tight limit to Y-axis', action='store_true')

    plot_g.add_argument('--subplots-adjust', help='Set margins for figure', metavar=('left', 'bottom', 'right', 'top'),
                        nargs=4, type=float)

    plot_g.add_argument('--confidence', help='Set confidence interval for error margin (percent value)',
                        type=float, default=95)

    plot_g.add_argument('--legend-position', help='Position of legend', nargs='*', default=('upper', 'center'))
    plot_g.add_argument('--legend-ncols', help='Number of columns in legend', default=2, type=int)

    return parser.parse_args()


def load_data(data_path: str, cols: Optional[List[str]] = None, smooth_span: Optional[float] = None) -> pd.DataFrame:
    d = pathlib.Path(data_path)
    pattern = '*.monitor.csv'
    assert d.exists(), 'Data directory/file does not exist'
    if d.is_dir():
        files = list(d.glob(pattern))
    elif d.is_file():
        files = [d]
    else:
        raise ValueError('Expected either a dir or a file')

    assert len(files) > 0, 'No *.monitor.csv files found in dir: {}'.format(str(d))
    return pd.concat([
        pd.read_csv(f, names=cols).ewm(span=smooth_span).mean() for f in files
    ], axis=0)


def filter_cols(data: pd.DataFrame, cols: Optional[List[str]] = None) -> pd.DataFrame:
    if not cols:
        return data
    assert set(cols).issubset(set(data.columns))
    return data[cols]


def get_stats(data: pd.DataFrame, confidence=0.95) -> Stats:
    import scipy.stats as stats
    g = data.groupby(data.index)
    mu, sig, err = g.mean(), g.std(), g.sem()
    ci = err * stats.t.ppf((1 + confidence) / 2.0, len(mu))
    return Stats(mu, sig, ci)


def plot_results(data: List[pd.DataFrame], args: argparse.Namespace):
    if args.pdf_output and args.output:
        mpl.use('pdf')

    data = [filter_cols(d, args.plot_cols) for d in data]

    ndata = len(data)
    nplots = len(args.plot_cols) if args.plot_cols else len(data[0].columns)
    nrows, ncols = args.subplot_shape

    n_xlabels = len(args.xlabel)
    n_ylabels = len(args.ylabel)

    assert nplots == nrows * ncols, \
        'Number of subplots needed ({}) != Number of subplots asked for ({})'.format(nplots, ncols * nrows)

    fig, axes = plt.subplots(nrows, ncols, sharex=args.sharex, sharey=args.sharey)
    if nplots == 1:
        axes = [axes]

    stats = [get_stats(d, args.confidence) for d in data]
    mu_vec, sig_vec, ci_vec = Stats(*zip(*stats))

    for i, ax in enumerate(axes):
        for j in range(ndata):
            col = args.plot_cols[i]
            mu, sig, ci = mu_vec[j][col], sig_vec[j][col], ci_vec[j][col]
            t = mu.index.values
            ax.plot(t, mu, '-')
            ax.fill_between(t, mu - ci, mu + ci, alpha=0.2)
        ax.set_xlabel(args.xlabel[min(i, n_xlabels - 1)])
        ax.set_ylabel(args.ylabel[min(i, n_ylabels - 1)])
        if args.xtight and args.ytight:
            tight_axis = 'both'
        else:
            tight_axis = 'x' if args.xtight else 'y'
        ax.autoscale(True, tight_axis, True)

    labels = tuple(args.name)
    fig.legend(labels, loc=' '.join(args.legend_position), ncol=args.legend_ncols, prop={'size': 8})

    if args.output:
        if args.subplots_adjust:
            adj = args.subplots_adjust
            fig.subplots_adjust(*adj)
        fig.set_size_inches(ncols * args.width, nrows * args.height)
        out_dir = os.path.dirname(args.output)
        os.makedirs(out_dir, exist_ok=True)
        fig.savefig(os.path.abspath(args.output))


if __name__ == '__main__':
    cli_args = parse_args()
    log.info(cli_args)
    plot_results(
        [load_data(d, cli_args.col, cli_args.smooth_span) for d in cli_args.logdir],
        cli_args
    )
